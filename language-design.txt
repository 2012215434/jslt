
---------------------------------------------------------------------------
LANGUAGE DESIGN

.       -> input
.foo    -> key in object
.[2]    -> index in array
.[1:2]  -> array slicing (just copy from Python)

==, !=, ... -> comparison

and, or, not(...)

+ * % / -   -> numeric operators
  string + string -> concat
  string * number -> repeat

$foo       -> variable reference
foo( ... ) -> function call

if (condition) <expr> else <expr>
let ...
  ISSUE: must be terminated somehow because with chainable expressions,
  how do you make clear that in
    let foo = $foo.bar
    .baz
  .baz is the actual expression and not part of the let?
  (this is an issue inside if and at toplevel, will also be inside functions)

  possible solutions:
    let var = ( expr )
    let var = expr;
    expr as $var <-- how is this now recognizable as let rather than expr?

  could require per let, or just at the end of the let block

for (<expr>) <expr>

[...]      -> array literal
{...}      -> object literal
"..."      -> string literal
34834      -> number literal
true|false -> boolean literal
null       -> what it says

*          -> matcher

----- ADD LATER, if at all

.foo [ condition ] -> FIXME: multiple results? how to deal with?
  inside condition we change the context node

  .foo .[*] .bar -> traverse array? how to deal with this?

can we do this by supporting
  for (<expr>) <expr> if <expr> ?

alternative:
  .[*] returns entire array
  .foo on array of objects = for (...) .foo

----- OPEN QUESTIONS

how to do fallback for missing values?
  function?
  operator?

----- FUNCTION LIBRARY

is-array()
is-object()

string(.)
is-string()

number(.)
is-number()
round()
floor()
ceiling()

boolean(.)
is-boolean()
not(.)

test(., regexp)
match(., regexp)    ?
capture(., regexp)
split(., splitter)
join(., joiner)
starts-with()
ends-with()
lowercase()
uppercase()

size(.) <- string, object, array

=== POTENTIALS

normalize-whitespace
format("...${ jstl expr }...")

=== AREAS TO COVER

datetime parsing
