
---------------------------------------------------------------------------
LANGUAGE DESIGN

.       -> input
.foo    -> key in object
.[2]    -> index in array
.[1:2]  -> array slicing (just copy from Python)

==, !=, ... -> comparison

and, or, not(...)

+ * % / -   -> numeric operators
  string + string -> concat
  string * number -> repeat

$foo       -> variable reference
foo( ... ) -> function call

if (condition) <expr> else <expr>
let ...
  ISSUE: must be terminated somehow because with chainable expressions,
  how do you make clear that in
    let foo = $foo.bar
    .baz
  .baz is the actual expression and not part of the let?
  (this is an issue inside if and at toplevel, will also be inside functions)

  possible solutions:
    let var = ( expr )
    let var = expr;
    expr as $var <-- how is this now recognizable as let rather than expr?

  could require per let, or just at the end of the let block

for (<expr>) <expr>

[...]      -> array literal
{...}      -> object literal
"..."      -> string literal
34834      -> number literal
true|false -> boolean literal
null       -> what it says

*          -> matcher

----- ADD LATER, if at all

.foo [ condition ] -> FIXME: multiple results? how to deal with?
  inside condition we change the context node

  .foo .[*] .bar -> traverse array? how to deal with this?

can we do this by supporting
  for (<expr>) <expr> if <expr> ?

alternative:
  .[*] returns entire array
  .foo on array of objects = for (...) .foo

FOR (...)
  ...
  IF (...)  <-- filter the array

----- OPEN QUESTIONS

termination of expression in LET: how?
  let foo = (...)
  let foo = ... ;
  let ... as $foo
  set ... as $foo

details of matcher semantics

what happens if you declare same variable twice in same block?

how strict should we be on type errors?
  anything + null -> null
  "foo" + 5       -> "foo5"
  "foo" + true    -> "footrue"
  "foo" + [1,2,3] -> ???
  5 + [1,2,3]     -> error
  5 + false       -> error
  [1,2,3] + {...} -> error

support 'for' loops over objects? {"key" : ..., "value" : ...}
how to support?
  .object."spt:custom" | with_entries(.key |= "spt:custom_" + .)

  {for (.object."spt:custom")
    "spt:custom_" + .key : .value
   if ()}

for loops: when iteration produces null, should it be added to the
  array?

how do {} and [] convert to strings?

more detail on implicit type conversion rules

allow .foo on array by applying to each element in array?
  -> raises need for [ ...boolean expr... ]
  -> if we want this extension . inside [] has to refer to the node

support ..foo operator?
  -> also raises need for [ filters ]

contains() vs 'in'?

----- FUNCTION LIBRARY

OK  is-array()
OK  is-object()

OK  string(.)
OK  is-string()

OK  number(.)
    is-number()
OK  round()
    floor()
    ceiling()
    random()             <- random number 0.0 - 1.0

    boolean(.)
    is-boolean()
OK  not(.)

OK  test(., regexp)
    match(., regexp)    ?
OK  capture(., regexp)
OK  split(., splitter)
OK  join(., joiner)
OK  starts-with()
OK  ends-with()
OK  lowercase()
    uppercase()

OK  fallback(...)
OK  size(.)              <- string, object, array
    parse-json(.)        <- parses json argument
    to-json(.)           <- serialize to json
    items(.)             <- turn {} into [{"key":, "value":}] ?

=== POTENTIALS

normalize-whitespace
format("...${ jstl expr }...")

=== AREAS TO COVER

datetime parsing

---------------------------------------------------------------------------
NAME

jslt         XSLT in JSON alternative, now dead
jsonator     ditto
j2j          already exists, but marginal
jstl         Oracle JavaServer Pages Standard Tag Library
argonator    kind of weird
jsonify      not really what it does
jtransform   an FFT thing, might work
jquery       taken by the frontend thing
colchis      cryptic
boreas       cryptic

-------------------------------------------------------------------------------
USE CASES

--- #1: TRUE/FALSE if .object.items contains {} with @Type==Jobs

{"object":{"items":[
  {"@Type" : "George"},
  {"@Type" : "Jobs"},
  {"@Type" : "Fnupp"}
]}}

solutions:

WORKS NOW    contains("Jobs", for (.object.items) ."@Type")

MIGHT DO     contains("Jobs", .object.items."@Type")
  requires .foo on arrays: apply to each object in array

MIGHT DO     "Jobs" in (for (.object.items) ."@Type")
  turn 'contains' function into 'in' operator
