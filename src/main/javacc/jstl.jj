
options {
  STATIC = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  TRACK_TOKENS = true;
}

PARSER_BEGIN(JstlParser)

package com.schibsted.spt.data.jstl2;

public class JstlParser {

}

PARSER_END(JstlParser)

/* WHITE SPACE */
SPECIAL_TOKEN :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
  < NULL: "null" > |
  < INTEGER: ("-")? (["0"-"9"])+ > |
  < DECIMAL: ("-")? (["0"-"9"])+ "." (["0"-"9"])+ > |
  < STRING: "\"" ((~["\""]) | ("\\" "\""))* "\"" > |
  < LBRACKET: "[" > |
  < RBRACKET: "]" > |
  < COMMA: "," > |
  < COLON: ":" > |
  < LCURLY: "{" > |
  < RCURLY: "}" > |
  < TRUE: "true" > |
  < FALSE: "false" > |
  < OR: "or" > |
  < AND: "and" > |
  < DOT: "." > |
  < IF: "if" > |
  < ELSE: "else" > |
  < LPAREN: "(" > |
  < RPAREN: ")" > |
  < LET: "let" > |
  < ASSIGN: "=" > |
  < EQUALS: "==" > |
  < UNEQUALS: "!=" > |
  < BIGOREQ: ">=" > |
  < PLUS: "+" > |
  < MINUS: "-" > |
  < STAR: "*" > |
  < SLASH: "/" > |
  < FOR: "for" > |
  < IDENT: (["A"-"Z"] | ["a"-"z"] | ["0"-"9"] | "_" | "-")+ > |
  < VARIABLE: "$" (["A"-"Z"] | ["a"-"z"] | ["0"-"9"] | "_" | "-")+ >
}

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


/** Root production. */
void Start() :
{}
{
  (Let())*
  Expr() <EOF>
}

void Expr() :
{}
{
  AndExpr() (<OR> Expr())?
}

void AndExpr() :
{}
{
  ComparativeExpr() (<AND> AndExpr())?
}

void ComparativeExpr() :
{}
{
  AdditiveExpr() (Comparator() AdditiveExpr())?
}

// not necessary, but makes the tree easier to traverse
void Comparator() :
{}
{
  <EQUALS> | <UNEQUALS> | <BIGOREQ>
}

void AdditiveExpr() :
{}
{
  MultiplicativeExpr() (AdditiveOperator() AdditiveExpr())?
}

// not necessary, but makes the tree easier to traverse
void AdditiveOperator() :
{}
{
  <PLUS> | <MINUS>
}

void MultiplicativeExpr() :
{}
{
  BaseExpr() (MultiplicativeOperator() MultiplicativeExpr())?
}

// not necessary, but makes the tree easier to traverse
void MultiplicativeOperator() :
{}
{
  <STAR> | <SLASH>
}

void BaseExpr() :
{}
{
  (<NULL> | <INTEGER> | <DECIMAL> | <STRING> | <TRUE> | <FALSE> |
   Chainable() | Parenthesis() |
   IfStatement() | For() |
   Array() | Object()
  )
}

void Chainable() :
{}
{
  (FunctionCall() | <VARIABLE> | <DOT> (<IDENT> | <STRING>)?)
  (ChainLink())?
}

void ChainLink() :
{}
{
  (DotKey() | ArraySlicing())
  (ChainLink())*
}

void Parenthesis() :
{}
{
  <LPAREN> Expr() <RPAREN>
}

void DotKey() :
{}
{
  <DOT> (<IDENT> | <STRING>)
}

void ArraySlicing() :
{}
{
  <LBRACKET> (Expr())? (Colon())? (Expr())? <RBRACKET>
}

void Colon() : {} { <COLON> } // need this to make parse tree manageable

void Array() :
{}
{
  <LBRACKET> (Expr() (<COMMA> Expr())*)? <RBRACKET>
}

void Object() :
{}
{
  <LCURLY>
    (Let())*
    (Pair() | Matcher())?
  <RCURLY>
}

void Matcher() :
{}
{
  <STAR> (MatcherMinus())? <COLON> Expr()
}

void MatcherMinus() :
{}
{
  <MINUS> (<IDENT> | <STRING>) (<COMMA> (<IDENT> | <STRING>))*
}

void Pair() :
{}
{
  <STRING> <COLON> Expr()
  (<COMMA> (Pair() | Matcher()))?
}

void IfStatement() :
{}
{
  <IF> <LPAREN> Expr() <RPAREN>
    (Let())*
    Expr()
    (ElseBranch())?
}

// not necessary, but makes it easier to walk the parse tree
void ElseBranch() :
{}
{
  <ELSE>
    (Let())*
    Expr()
}

void For() :
{}
{
  <FOR> <LPAREN> Expr() <RPAREN> Expr()
}

void FunctionCall() :
{}
{
  <IDENT> <LPAREN> (Expr() (<COMMA> Expr())*)? <RPAREN>
}

void Let() :
{}
{
  <LET> <IDENT> <ASSIGN> Expr()
}
