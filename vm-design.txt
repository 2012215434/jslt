
===========================================================================
VM DESIGN

---------------------------------------------------------------------------
OPTIMIZATION OPPORTUNITIES

VM ONLY
  compile not and fallback into bytecode
  put strings into separate pool (so don't have to make TextNodes)
  bake array index into opcode for speed
  and/or boolean short-circuit

GENERAL
  turn fallback into a macro
  single-use variables can be inlined

  if (a) a else b -> fallback(a, b)

NO MEASURABLE EFFECT (tried)
  more efficient function calls with static parameter list

---------------------------------------------------------------------------
OVERVIEW

The VM internally contains:
  Variables[][] =
    first level is scope
    second level is variables indexed by number

  Map = variable -> index number

  Literals[] = JsonNode objects indexed by number
  Functions[] = Function objects indexed by number

  Code[] = VM bytecode on the format (array of ints)
    instr op (first instr is 0 and 1, second 2 and 3, ...)
    instr op
    instr op

  pc -> pointer into Code[] to next instruction

  Stack[] -> stack of JsonNode objects
    this includes object keys as StringNode objects (to make ev'thing the same)

  stp -> pointer into Stack[] to top
  scp -> pointer into Variables[] stack frame

  Input = the JSON object we're operating on

OPCODES:
  PUSHO _   create new object, put on stack
  PUSHL ix  push Literals[ix] on the stack
  PUSHV ix  push Variables[scp][ix] on the stack
  PUSHI _   push Input on stack
  DOT   ix  pop object/array from stack, index w/ Literals[ix], push result
  CALL  ix  call that function (number of params pushed on stack first?)
  STORE ix  pop from stack, store to Variables[scp][ix]
  PUSHS _   increment scp, add new stack frame
  POPS  _   decrement scp (discard stack frame)
  DUP   _   duplicate object on stack

PULSE-CLEANUP BYTECODE
  PUSHO 0
  PUSHL "actor" (really index of this literal)
  PUSHO 0
  PUSHS 0
  PUSHI 0
  DOT   "actor" (index of literal)
  DOT   "@id"
  PUSHL that long regexp
  CALL  test (not sure how to communicate how many args to pop)
  JNOT  else:
  PUSHI 0
  DOT   "actor"
  DOT   "@id"
  JUMP  assign:
else:
  PUSHI 0
  DOT   "actor"
  DOT   "spt:userId"
assign:
  STORE $userid

  PUSHV $userid
  PUSHL long regexp
  CALL  test (args?!)
  JNOT  else2:
  PUSHL null
else2:
  ...

---------------------------------------------------------------------------
FOR LOOPS

ALD _: sets up stack as follows
  true
  elem 0
  array
  true
  elem 1
  array
  true
  elem 2
  array
  true
  elem 3
  array
  false    <-- terminator
  array

  PUSHI -> save input on stack
  compute array
  dup
  jnot end:      to verify we actually found an array
  ALD   -> set up stack

  JNOT end:
start:
  <current array elem on top of stack>
  POPI  -> make top of stack be input
  compute for body
  <stack now is: new elem, array, ...>
  SETA
  POP   -> remove the array
  <bool, elem, array on top of stack>
  JUMP start:

end:
  <array now on top of stack, previous input below it>
  SWAP  <- swap two top stack elements
  POPI  <- restore input from stack

bitterend:
  <array now on top of stack>

---------------------------------------------------------------------------
OBJECT MATCHER

starting point:
  - result object, being populated, on top of stack
  - can generate bytecode to produce input object
  - keyset of forbidden keys can be turned into literal

<result object on top of stack>
  dup
  jnot bitterend:      to verify we actually found an object
  pushi save input on stack
  swap (result on top, input below)
  compute matching object
  <mathed object, result, input>
  smear onto stack: result, false, obj, value, key, obj, value, key, ...

start:
  dup top again (key)
  push keyset
  call contains
  jnot body:
  pop the value
  jump start:
body:
  <stack is still key, value>
  swap (so value is on top)
  popi (make value be the input)

  inject matcher expression here (usually .)
  <stack is now keyval, key, obj, key, val, obj, key val, obj, ...>
  DSETK pops keyval, key, obj off stack
  jump start:

end:
  <stack from top: terminator, result, saved input>
  pop
  swap
  popi restores input
  <result now on top>
